# 주어진 트리에서 특정 노드를 지울 때 남은 리프 노드의 개수를 계산하시오.

import sys
input = sys.stdin.readline

# 깊이우선탐색
def dfs(num, arr):    # num: 현재 노드 번호, arr: 노드들의 부모를 나타내는 리스트
    arr[num] = -2     # 전달받은 인덱스의 배열 값을 삭제한다는 의미로 -2로 갱신 (-1은 루트노드와 겹치므로 피해야함)
    for i in range(len(arr)):
        if num == arr[i]:
            dfs(i, arr)
            
n = int(input())                         # 노드의 개수 입력받기
arr = list(map(int, input().split()))    # 각 노드의 부모를 나타내는 리스트 받기
k = int(input())                         # 지울 노드의 번호 입력받기
count = 0                                # count (리프 노드의 개수 저장) 변수 초기화

dfs(k, arr)                              # 입력받은 노드를 지우기 위해 dfs 호출
count = 0
for i in range(len(arr)):
    if arr[i] != -2 and i not in arr:    # -2가 아니면서, 다른 노드의 부모노드도 아닌 것 (즉 지워지지 않았고, 리프노드인 경우)
        count += 1                       # 찾을 때마다 + 1
print(count)

"""
1. 입력된 인덱스를 dfs함수에 트리 배열과 함께 전달한다.
2. dfs함수
  2-1. 전달받은 인덱스의 배열 값을 삭제한다는 의미로 -2로 바꾼다. (-1은 루트노드와 겹치므로 피한다.)
  2-2. 배열 전체를 탐색하며, 방금 삭제한 인덱스를 부모노드로 가지는 노드를 찾아 dfs함수를 재귀호출한다.
3. 재귀가 끝나면 삭제될 노드들은 전부 -2로 갱신되어있으므로,
   -2가 아니면서, 다른 노드의 부모노드도 아닌 원소를 찾을 때마다 count를 1씩 늘린다.

==> 입력된 트리에서 특정 노드를 지우고, 지워진 노드를 제외한 나머지 노드 중 리프 노드의 개수를 계산하는 과정을 수행
"""
