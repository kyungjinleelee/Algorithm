# 문제 주소: https://www.acmicpc.net/problem/20055
"""
회전은 deque의 rotate 함수를 활용해 구현함.
로봇은 내리는 위치에서 없어지기 때문에 길이는 컨베이어 벨트의 반으로 정해줌.

구현 과정:
1단계: 벨트와 로봇을 회전해준 후, 내리는 위치의 로봇을 0으로 바꿔준다.
2단계: 로봇이 존재할 때, 로봇 배열 끝-1 에서부터 로봇이 있고 다음 자리에 로봇이 없고 벨트의 내구도가 1 이상이면, 현재 자리의 로봇을 0으로 바꾸고 로봇을 옮기고 벨트의 내구도를 1 감소시킨다.. 그 후 내리는 위치의 로봇을 내려준다.
3단계: 로봇의 올리는 위치에 로봇이 없고, 벨트의 내구도가 0이 아니라면 로봇을 올리고 내구도를 감소시킨다.
4단계: 벨트의 내구도가 0인게 k 이상이면 종료시킨다. 아니라면 정답을 1 증가시킨다.
"""

from collections import deque

n,k = map(int, input().split())              # n: 컨베이어 벨트의 길이, k: 내구도가 0인 칸의 최대 갯수
"""
컨베이어 벨트는 길이: 2n, 앞쪽 n칸과 뒤쪽 n칸이 서로 이어져 있음
따라서 n은 전체 벨트 길이의 반을 나타냄
내구도가 0인 칸의 최대개수가 k이므로, k는 종료 조건으로 사용됨
벨트 위에 있는 내구도가 k 이상이 되면 시뮬레이션을 종료
"""
belt = deque(list(map(int, input().split())))
robot = deque([0]*(len(belt)//2))      # 로봇의 위치를 나타내는 덱 생성. 로봇은 벨트 길이의 절반에 위치할 수 있으므로 len(belt)//2 길이의 0으로 초기화된 덱 생성함
answer = 0      

while True:      # 무한루프 시작
  # 1단계
  belt.rotate(1)     # 벨트를 오른쪽으로 한 칸 회전
  robot.rotate(1)    # 로봇을 오른쪽으로 한 칸 회전 (deque의 rotate함수)
  # 로봇이 있는 위치는 벨트와 같이 회전함 > 로봇의 위치를 나타내는 덱도 같이 회전시켜줌
  # 회전 후 로봇이 벨트의 끝으로 이동했을 경우, 벨트의 끝에 로봇이 있으면 로봇이 벨트에서 내려가야 함
  robot[-1] = 0      # 가장 오른쪽에 있는 로봇(=내리는 위치)을 0으로 바꿔서 내려가게 함 (-1: 가장 마지막 요소를 나타냄)

  # 2단계: 로봇의 이동과 함께 벨트의 내구도가 감소하는 과정
  if sum(robot):  # 현재 로봇이 하나라도 존재하면 
    for i in range(-2, -n-1, -1):
      if robot[i] == 1 and robot[i+1] == 0 and belt[i+1-n] >= 1:
        robot[i] = 0
        robot[i+1] = 1
        belt[i+1-n] -= 1
    robot[-1] = 0

  # 3단계
  if robot[0] == 0 and belt[0] != 0:
    robot[0] = 1
    belt[0] -= 1

  # 4단계
  if belt.count(0) >= k:
    break
  answer+=1

print(answer)

"""
Q. collections 모듈의 deque 클래스의 rotate 함수란?
A. 덱의 요소들을 지정한 만큼 회전시키는 메서드임.
여기서 덱은 양방향 큐로, 양쪽 끝에서 요소를 추가하거나 제거할 수 있는 자료구조를 말함.
rotate 함수는 매개변수로 회전시킬 거리를 받음. 
양수 값을 넣으면 오른쪽으로 회전하고, 음수 값을 넣으면 왼쪽으로 회전함. 회전된 결과는 기존의 덱을 변경시킴.
"""
